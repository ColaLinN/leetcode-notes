





如题，同向双指针是一种可变的滑动窗口，只不过零把固定的叫做滑动窗口罢了



01 [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

Subarray: A **subarray** is a contiguous **non-empty** sequence of elements within an array.

```
func minSubArrayLen(target int, nums []int) int {
    left := 0
    minLen := len(nums) + 1 // This is to mock the infinite
    sum := 0
    for right := 0 ; right < len(nums) ; right++ {
        sum += nums[right]
        for sum >= target {
            if minLen > right - left + 1 {
                minLen = right - left + 1
            }
            sum -= nums[left]
            left++
        }
    }
    if minLen == len(nums) + 1 { // Skip the non-updated case
        return 0
    } else {
        return minLen
    }
}
```



02 [3. 无重复字符的最长子串 ](https://leetcode.cn/problems/longest-substring-without-repeating-characters/) [3. Longest Substring Without Repeating Characters](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

```
func lengthOfLongestSubstring(s string) int {
    charMap := make(map[byte]bool)
    res := 0
    left := 0
    for right := 0 ; right < len(s); right++ {
        for charMap[s[right]] {
            charMap[s[left]] = false
            left++
        }
        charMap[s[right]] = true
        if res < right - left + 1 {
            res = right - left + 1
        }
    }
    return res
}
```



03 [713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/) [713. Subarray Product Less Than K](https://leetcode.cn/problems/subarray-product-less-than-k/)

```
func numSubarrayProductLessThanK(nums []int, k int) int {
    // left = 0
    // right starts from 0
    // if product <= k, 
    //      it means the [left, right], [left+1, right], ..., [right, right] all meet the requirement
    //      and we can proceed right++
    // else, we can proceed left++ until product <= k
    left := 0
    cnt := 0
    product := 1
    // edge case, when the target k is 1, it's impossible to find a subarrays 
    // based on the current constraints 1 <= nums[i]
    // it's also for preventing the codes trapping into the infinite loop
    if k <= 1 {
        return 0
    }
    for right := 0 ; right < len(nums) ; right++ {
        product *= nums[right]
        for product >= k { // it implies that the left <= right, the minimum of product is 1
            product /= nums[left]
            left++
        }
        if product < k { // only cares about the cases which are less than the target
            cnt += right-left+1
        }
    }
    return cnt
}
```

